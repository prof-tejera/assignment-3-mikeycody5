{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\nimport { EnterLeaveCounter } from './EnterLeaveCounter.js';\nimport { createNativeDragSource, matchNativeItemType } from './NativeDragSources/index.js';\nimport * as NativeTypes from './NativeTypes.js';\nimport { getDragPreviewOffset, getEventClientOffset, getNodeClientOffset } from './OffsetUtils.js';\nimport { OptionsReader } from './OptionsReader.js';\nexport class HTML5BackendImpl {\n  /**\n  * Generate profiling statistics for the HTML5Backend.\n  */\n  profile() {\n    var ref, ref1;\n    return {\n      sourcePreviewNodes: this.sourcePreviewNodes.size,\n      sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n      sourceNodeOptions: this.sourceNodeOptions.size,\n      sourceNodes: this.sourceNodes.size,\n      dragStartSourceIds: ((ref = this.dragStartSourceIds) === null || ref === void 0 ? void 0 : ref.length) || 0,\n      dropTargetIds: this.dropTargetIds.length,\n      dragEnterTargetIds: this.dragEnterTargetIds.length,\n      dragOverTargetIds: ((ref1 = this.dragOverTargetIds) === null || ref1 === void 0 ? void 0 : ref1.length) || 0\n    };\n  }\n  // public for test\n  get window() {\n    return this.options.window;\n  }\n  get document() {\n    return this.options.document;\n  }\n  /**\n  * Get the root element to use for event subscriptions\n  */\n  get rootElement() {\n    return this.options.rootElement;\n  }\n  setup() {\n    const root = this.rootElement;\n    if (root === undefined) {\n      return;\n    }\n    if (root.__isReactDndBackendSetUp) {\n      throw new Error('Cannot have two HTML5 backends at the same time.');\n    }\n    root.__isReactDndBackendSetUp = true;\n    this.addEventListeners(root);\n  }\n  teardown() {\n    const root = this.rootElement;\n    if (root === undefined) {\n      return;\n    }\n    root.__isReactDndBackendSetUp = false;\n    this.removeEventListeners(this.rootElement);\n    this.clearCurrentDragSourceNode();\n    if (this.asyncEndDragFrameId) {\n      var ref;\n      (ref = this.window) === null || ref === void 0 ? void 0 : ref.cancelAnimationFrame(this.asyncEndDragFrameId);\n    }\n  }\n  connectDragPreview(sourceId, node, options) {\n    this.sourcePreviewNodeOptions.set(sourceId, options);\n    this.sourcePreviewNodes.set(sourceId, node);\n    return () => {\n      this.sourcePreviewNodes.delete(sourceId);\n      this.sourcePreviewNodeOptions.delete(sourceId);\n    };\n  }\n  connectDragSource(sourceId, node, options) {\n    this.sourceNodes.set(sourceId, node);\n    this.sourceNodeOptions.set(sourceId, options);\n    const handleDragStart = e => this.handleDragStart(e, sourceId);\n    const handleSelectStart = e => this.handleSelectStart(e);\n    node.setAttribute('draggable', 'true');\n    node.addEventListener('dragstart', handleDragStart);\n    node.addEventListener('selectstart', handleSelectStart);\n    return () => {\n      this.sourceNodes.delete(sourceId);\n      this.sourceNodeOptions.delete(sourceId);\n      node.removeEventListener('dragstart', handleDragStart);\n      node.removeEventListener('selectstart', handleSelectStart);\n      node.setAttribute('draggable', 'false');\n    };\n  }\n  connectDropTarget(targetId, node) {\n    const handleDragEnter = e => this.handleDragEnter(e, targetId);\n    const handleDragOver = e => this.handleDragOver(e, targetId);\n    const handleDrop = e => this.handleDrop(e, targetId);\n    node.addEventListener('dragenter', handleDragEnter);\n    node.addEventListener('dragover', handleDragOver);\n    node.addEventListener('drop', handleDrop);\n    return () => {\n      node.removeEventListener('dragenter', handleDragEnter);\n      node.removeEventListener('dragover', handleDragOver);\n      node.removeEventListener('drop', handleDrop);\n    };\n  }\n  addEventListeners(target) {\n    // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813\n    if (!target.addEventListener) {\n      return;\n    }\n    target.addEventListener('dragstart', this.handleTopDragStart);\n    target.addEventListener('dragstart', this.handleTopDragStartCapture, true);\n    target.addEventListener('dragend', this.handleTopDragEndCapture, true);\n    target.addEventListener('dragenter', this.handleTopDragEnter);\n    target.addEventListener('dragenter', this.handleTopDragEnterCapture, true);\n    target.addEventListener('dragleave', this.handleTopDragLeaveCapture, true);\n    target.addEventListener('dragover', this.handleTopDragOver);\n    target.addEventListener('dragover', this.handleTopDragOverCapture, true);\n    target.addEventListener('drop', this.handleTopDrop);\n    target.addEventListener('drop', this.handleTopDropCapture, true);\n  }\n  removeEventListeners(target) {\n    // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813\n    if (!target.removeEventListener) {\n      return;\n    }\n    target.removeEventListener('dragstart', this.handleTopDragStart);\n    target.removeEventListener('dragstart', this.handleTopDragStartCapture, true);\n    target.removeEventListener('dragend', this.handleTopDragEndCapture, true);\n    target.removeEventListener('dragenter', this.handleTopDragEnter);\n    target.removeEventListener('dragenter', this.handleTopDragEnterCapture, true);\n    target.removeEventListener('dragleave', this.handleTopDragLeaveCapture, true);\n    target.removeEventListener('dragover', this.handleTopDragOver);\n    target.removeEventListener('dragover', this.handleTopDragOverCapture, true);\n    target.removeEventListener('drop', this.handleTopDrop);\n    target.removeEventListener('drop', this.handleTopDropCapture, true);\n  }\n  getCurrentSourceNodeOptions() {\n    const sourceId = this.monitor.getSourceId();\n    const sourceNodeOptions = this.sourceNodeOptions.get(sourceId);\n    return _objectSpread({\n      dropEffect: this.altKeyPressed ? 'copy' : 'move'\n    }, sourceNodeOptions || {});\n  }\n  getCurrentDropEffect() {\n    if (this.isDraggingNativeItem()) {\n      // It makes more sense to default to 'copy' for native resources\n      return 'copy';\n    }\n    return this.getCurrentSourceNodeOptions().dropEffect;\n  }\n  getCurrentSourcePreviewNodeOptions() {\n    const sourceId = this.monitor.getSourceId();\n    const sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);\n    return _objectSpread({\n      anchorX: 0.5,\n      anchorY: 0.5,\n      captureDraggingState: false\n    }, sourcePreviewNodeOptions || {});\n  }\n  isDraggingNativeItem() {\n    const itemType = this.monitor.getItemType();\n    return Object.keys(NativeTypes).some(key => NativeTypes[key] === itemType);\n  }\n  beginDragNativeItem(type, dataTransfer) {\n    this.clearCurrentDragSourceNode();\n    this.currentNativeSource = createNativeDragSource(type, dataTransfer);\n    this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);\n    this.actions.beginDrag([this.currentNativeHandle]);\n  }\n  setCurrentDragSourceNode(node) {\n    this.clearCurrentDragSourceNode();\n    this.currentDragSourceNode = node;\n    // A timeout of > 0 is necessary to resolve Firefox issue referenced\n    // See:\n    //   * https://github.com/react-dnd/react-dnd/pull/928\n    //   * https://github.com/react-dnd/react-dnd/issues/869\n    const MOUSE_MOVE_TIMEOUT = 1000;\n    // Receiving a mouse event in the middle of a dragging operation\n    // means it has ended and the drag source node disappeared from DOM,\n    // so the browser didn't dispatch the dragend event.\n    //\n    // We need to wait before we start listening for mousemove events.\n    // This is needed because the drag preview needs to be drawn or else it fires an 'mousemove' event\n    // immediately in some browsers.\n    //\n    // See:\n    //   * https://github.com/react-dnd/react-dnd/pull/928\n    //   * https://github.com/react-dnd/react-dnd/issues/869\n    //\n    this.mouseMoveTimeoutTimer = setTimeout(() => {\n      var ref;\n      return (ref = this.rootElement) === null || ref === void 0 ? void 0 : ref.addEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);\n    }, MOUSE_MOVE_TIMEOUT);\n  }\n  clearCurrentDragSourceNode() {\n    if (this.currentDragSourceNode) {\n      this.currentDragSourceNode = null;\n      if (this.rootElement) {\n        var ref;\n        (ref = this.window) === null || ref === void 0 ? void 0 : ref.clearTimeout(this.mouseMoveTimeoutTimer || undefined);\n        this.rootElement.removeEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);\n      }\n      this.mouseMoveTimeoutTimer = null;\n      return true;\n    }\n    return false;\n  }\n  handleDragStart(e, sourceId) {\n    if (e.defaultPrevented) {\n      return;\n    }\n    if (!this.dragStartSourceIds) {\n      this.dragStartSourceIds = [];\n    }\n    this.dragStartSourceIds.unshift(sourceId);\n  }\n  handleDragEnter(_e, targetId) {\n    this.dragEnterTargetIds.unshift(targetId);\n  }\n  handleDragOver(_e, targetId) {\n    if (this.dragOverTargetIds === null) {\n      this.dragOverTargetIds = [];\n    }\n    this.dragOverTargetIds.unshift(targetId);\n  }\n  handleDrop(_e, targetId) {\n    this.dropTargetIds.unshift(targetId);\n  }\n  constructor(manager, globalContext, options) {\n    this.sourcePreviewNodes = new Map();\n    this.sourcePreviewNodeOptions = new Map();\n    this.sourceNodes = new Map();\n    this.sourceNodeOptions = new Map();\n    this.dragStartSourceIds = null;\n    this.dropTargetIds = [];\n    this.dragEnterTargetIds = [];\n    this.currentNativeSource = null;\n    this.currentNativeHandle = null;\n    this.currentDragSourceNode = null;\n    this.altKeyPressed = false;\n    this.mouseMoveTimeoutTimer = null;\n    this.asyncEndDragFrameId = null;\n    this.dragOverTargetIds = null;\n    this.lastClientOffset = null;\n    this.hoverRafId = null;\n    this.getSourceClientOffset = sourceId => {\n      const source = this.sourceNodes.get(sourceId);\n      return source && getNodeClientOffset(source) || null;\n    };\n    this.endDragNativeItem = () => {\n      if (!this.isDraggingNativeItem()) {\n        return;\n      }\n      this.actions.endDrag();\n      if (this.currentNativeHandle) {\n        this.registry.removeSource(this.currentNativeHandle);\n      }\n      this.currentNativeHandle = null;\n      this.currentNativeSource = null;\n    };\n    this.isNodeInDocument = node => {\n      // Check the node either in the main document or in the current context\n      return Boolean(node && this.document && this.document.body && this.document.body.contains(node));\n    };\n    this.endDragIfSourceWasRemovedFromDOM = () => {\n      const node = this.currentDragSourceNode;\n      if (node == null || this.isNodeInDocument(node)) {\n        return;\n      }\n      if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {\n        this.actions.endDrag();\n      }\n      this.cancelHover();\n    };\n    this.scheduleHover = dragOverTargetIds => {\n      if (this.hoverRafId === null && typeof requestAnimationFrame !== 'undefined') {\n        this.hoverRafId = requestAnimationFrame(() => {\n          if (this.monitor.isDragging()) {\n            this.actions.hover(dragOverTargetIds || [], {\n              clientOffset: this.lastClientOffset\n            });\n          }\n          this.hoverRafId = null;\n        });\n      }\n    };\n    this.cancelHover = () => {\n      if (this.hoverRafId !== null && typeof cancelAnimationFrame !== 'undefined') {\n        cancelAnimationFrame(this.hoverRafId);\n        this.hoverRafId = null;\n      }\n    };\n    this.handleTopDragStartCapture = () => {\n      this.clearCurrentDragSourceNode();\n      this.dragStartSourceIds = [];\n    };\n    this.handleTopDragStart = e => {\n      if (e.defaultPrevented) {\n        return;\n      }\n      const {\n        dragStartSourceIds\n      } = this;\n      this.dragStartSourceIds = null;\n      const clientOffset = getEventClientOffset(e);\n      // Avoid crashing if we missed a drop event or our previous drag died\n      if (this.monitor.isDragging()) {\n        this.actions.endDrag();\n        this.cancelHover();\n      }\n      // Don't publish the source just yet (see why below)\n      this.actions.beginDrag(dragStartSourceIds || [], {\n        publishSource: false,\n        getSourceClientOffset: this.getSourceClientOffset,\n        clientOffset\n      });\n      const {\n        dataTransfer\n      } = e;\n      const nativeType = matchNativeItemType(dataTransfer);\n      if (this.monitor.isDragging()) {\n        if (dataTransfer && typeof dataTransfer.setDragImage === 'function') {\n          // Use custom drag image if user specifies it.\n          // If child drag source refuses drag but parent agrees,\n          // use parent's node as drag image. Neither works in IE though.\n          const sourceId = this.monitor.getSourceId();\n          const sourceNode = this.sourceNodes.get(sourceId);\n          const dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode;\n          if (dragPreview) {\n            const {\n              anchorX,\n              anchorY,\n              offsetX,\n              offsetY\n            } = this.getCurrentSourcePreviewNodeOptions();\n            const anchorPoint = {\n              anchorX,\n              anchorY\n            };\n            const offsetPoint = {\n              offsetX,\n              offsetY\n            };\n            const dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);\n            dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);\n          }\n        }\n        try {\n          // Firefox won't drag without setting data\n          dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.setData('application/json', {});\n        } catch (err) {\n          // IE doesn't support MIME types in setData\n        }\n        // Store drag source node so we can check whether\n        // it is removed from DOM and trigger endDrag manually.\n        this.setCurrentDragSourceNode(e.target);\n        // Now we are ready to publish the drag source.. or are we not?\n        const {\n          captureDraggingState\n        } = this.getCurrentSourcePreviewNodeOptions();\n        if (!captureDraggingState) {\n          // Usually we want to publish it in the next tick so that browser\n          // is able to screenshot the current (not yet dragging) state.\n          //\n          // It also neatly avoids a situation where render() returns null\n          // in the same tick for the source element, and browser freaks out.\n          setTimeout(() => this.actions.publishDragSource(), 0);\n        } else {\n          // In some cases the user may want to override this behavior, e.g.\n          // to work around IE not supporting custom drag previews.\n          //\n          // When using a custom drag layer, the only way to prevent\n          // the default drag preview from drawing in IE is to screenshot\n          // the dragging state in which the node itself has zero opacity\n          // and height. In this case, though, returning null from render()\n          // will abruptly end the dragging, which is not obvious.\n          //\n          // This is the reason such behavior is strictly opt-in.\n          this.actions.publishDragSource();\n        }\n      } else if (nativeType) {\n        // A native item (such as URL) dragged from inside the document\n        this.beginDragNativeItem(nativeType);\n      } else if (dataTransfer && !dataTransfer.types && (e.target && !e.target.hasAttribute || !e.target.hasAttribute('draggable'))) {\n        // Looks like a Safari bug: dataTransfer.types is null, but there was no draggable.\n        // Just let it drag. It's a native type (URL or text) and will be picked up in\n        // dragenter handler.\n        return;\n      } else {\n        // If by this time no drag source reacted, tell browser not to drag.\n        e.preventDefault();\n      }\n    };\n    this.handleTopDragEndCapture = () => {\n      if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {\n        // Firefox can dispatch this event in an infinite loop\n        // if dragend handler does something like showing an alert.\n        // Only proceed if we have not handled it already.\n        this.actions.endDrag();\n      }\n      this.cancelHover();\n    };\n    this.handleTopDragEnterCapture = e => {\n      this.dragEnterTargetIds = [];\n      if (this.isDraggingNativeItem()) {\n        var ref;\n        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n      }\n      const isFirstEnter = this.enterLeaveCounter.enter(e.target);\n      if (!isFirstEnter || this.monitor.isDragging()) {\n        return;\n      }\n      const {\n        dataTransfer\n      } = e;\n      const nativeType = matchNativeItemType(dataTransfer);\n      if (nativeType) {\n        // A native item (such as file or URL) dragged from outside the document\n        this.beginDragNativeItem(nativeType, dataTransfer);\n      }\n    };\n    this.handleTopDragEnter = e => {\n      const {\n        dragEnterTargetIds\n      } = this;\n      this.dragEnterTargetIds = [];\n      if (!this.monitor.isDragging()) {\n        // This is probably a native item type we don't understand.\n        return;\n      }\n      this.altKeyPressed = e.altKey;\n      // If the target changes position as the result of `dragenter`, `dragover` might still\n      // get dispatched despite target being no longer there. The easy solution is to check\n      // whether there actually is a target before firing `hover`.\n      if (dragEnterTargetIds.length > 0) {\n        this.actions.hover(dragEnterTargetIds, {\n          clientOffset: getEventClientOffset(e)\n        });\n      }\n      const canDrop = dragEnterTargetIds.some(targetId => this.monitor.canDropOnTarget(targetId));\n      if (canDrop) {\n        // IE requires this to fire dragover events\n        e.preventDefault();\n        if (e.dataTransfer) {\n          e.dataTransfer.dropEffect = this.getCurrentDropEffect();\n        }\n      }\n    };\n    this.handleTopDragOverCapture = e => {\n      this.dragOverTargetIds = [];\n      if (this.isDraggingNativeItem()) {\n        var ref;\n        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n      }\n    };\n    this.handleTopDragOver = e => {\n      const {\n        dragOverTargetIds\n      } = this;\n      this.dragOverTargetIds = [];\n      if (!this.monitor.isDragging()) {\n        // This is probably a native item type we don't understand.\n        // Prevent default \"drop and blow away the whole document\" action.\n        e.preventDefault();\n        if (e.dataTransfer) {\n          e.dataTransfer.dropEffect = 'none';\n        }\n        return;\n      }\n      this.altKeyPressed = e.altKey;\n      this.lastClientOffset = getEventClientOffset(e);\n      this.scheduleHover(dragOverTargetIds);\n      const canDrop = (dragOverTargetIds || []).some(targetId => this.monitor.canDropOnTarget(targetId));\n      if (canDrop) {\n        // Show user-specified drop effect.\n        e.preventDefault();\n        if (e.dataTransfer) {\n          e.dataTransfer.dropEffect = this.getCurrentDropEffect();\n        }\n      } else if (this.isDraggingNativeItem()) {\n        // Don't show a nice cursor but still prevent default\n        // \"drop and blow away the whole document\" action.\n        e.preventDefault();\n      } else {\n        e.preventDefault();\n        if (e.dataTransfer) {\n          e.dataTransfer.dropEffect = 'none';\n        }\n      }\n    };\n    this.handleTopDragLeaveCapture = e => {\n      if (this.isDraggingNativeItem()) {\n        e.preventDefault();\n      }\n      const isLastLeave = this.enterLeaveCounter.leave(e.target);\n      if (!isLastLeave) {\n        return;\n      }\n      if (this.isDraggingNativeItem()) {\n        setTimeout(() => this.endDragNativeItem(), 0);\n      }\n      this.cancelHover();\n    };\n    this.handleTopDropCapture = e => {\n      this.dropTargetIds = [];\n      if (this.isDraggingNativeItem()) {\n        var ref;\n        e.preventDefault();\n        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n      } else if (matchNativeItemType(e.dataTransfer)) {\n        // Dragging some elements, like <a> and <img> may still behave like a native drag event,\n        // even if the current drag event matches a user-defined type.\n        // Stop the default behavior when we're not expecting a native item to be dropped.\n        e.preventDefault();\n      }\n      this.enterLeaveCounter.reset();\n    };\n    this.handleTopDrop = e => {\n      const {\n        dropTargetIds\n      } = this;\n      this.dropTargetIds = [];\n      this.actions.hover(dropTargetIds, {\n        clientOffset: getEventClientOffset(e)\n      });\n      this.actions.drop({\n        dropEffect: this.getCurrentDropEffect()\n      });\n      if (this.isDraggingNativeItem()) {\n        this.endDragNativeItem();\n      } else if (this.monitor.isDragging()) {\n        this.actions.endDrag();\n      }\n      this.cancelHover();\n    };\n    this.handleSelectStart = e => {\n      const target = e.target;\n      // Only IE requires us to explicitly say\n      // we want drag drop operation to start\n      if (typeof target.dragDrop !== 'function') {\n        return;\n      }\n      // Inputs and textareas should be selectable\n      if (target.tagName === 'INPUT' || target.tagName === 'SELECT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n        return;\n      }\n      // For other targets, ask IE\n      // to enable drag and drop\n      e.preventDefault();\n      target.dragDrop();\n    };\n    this.options = new OptionsReader(globalContext, options);\n    this.actions = manager.getActions();\n    this.monitor = manager.getMonitor();\n    this.registry = manager.getRegistry();\n    this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}